pipeline {
  agent any

  environment {
    BACKEND_REPO      = 'gerryaj2004/proactively-backend'
    FRONTEND_REPO     = 'gerryaj2004/proactively-frontend'
    EC2_HOST          = '13.201.4.53'
    BACKEND_HOST_PORT = '8081'     // <-- host port to map to container's 8080
  }

  stages {
    stage('Checkout') {
      steps {
        echo 'üì• Checking out source code...'
        checkout scm
      }
    }

    stage('Build Backend') {
      steps {
        dir('backend') {
          echo 'üì¶ Installing backend dependencies...'
          sh 'npm install'
          echo '‚öôÔ∏è Building backend (if build script exists)...'
          sh 'npm run build || echo "No build script found in backend/package.json; skipping build."'
        }
      }
    }

    stage('Build Frontend') {
      steps {
        dir('frontend') {
          echo 'üì¶ Installing frontend dependencies...'
          sh 'npm install'
          echo '‚öôÔ∏è Building frontend...'
          sh 'npm run build'
        }
      }
    }

    stage('Docker Login (use Jenkins credential)') {
      steps {
        script {
          withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USER_TMP', passwordVariable: 'DOCKER_PASS_TMP')]) {
            env.DOCKER_USER = DOCKER_USER_TMP
            def rc = sh(returnStatus: true, script: 'echo "$DOCKER_PASS_TMP" | docker login -u "$DOCKER_USER_TMP" --password-stdin')
            if (rc != 0) {
              error("Docker login failed (exit code ${rc}). Check dockerhub-credentials (use Docker Hub token/password).")
            }
            echo "Docker login succeeded as ${env.DOCKER_USER}"
          }
        }
      }
    }

    stage('Build & Push Images') {
      steps {
        script {
          def tag = env.BUILD_NUMBER ?: 'latest'
          def backendTag = "${env.BACKEND_REPO}:${tag}"
          def frontendTag = "${env.FRONTEND_REPO}:${tag}"

          echo "üê≥ Building and pushing images:"
          echo "  - ${backendTag}"
          echo "  - ${frontendTag}"

          if (fileExists('backend/Dockerfile')) {
            sh "docker build -t ${backendTag} -f backend/Dockerfile backend"
          } else if (fileExists('backend/DockerFile')) {
            sh "docker build -t ${backendTag} -f backend/DockerFile backend"
          } else {
            error "Backend Dockerfile not found (backend/Dockerfile or backend/DockerFile)."
          }

          if (fileExists('frontend/Dockerfile')) {
            sh "docker build -t ${frontendTag} -f frontend/Dockerfile frontend"
          } else if (fileExists('frontend/DockerFile')) {
            sh "docker build -t ${frontendTag} -f frontend/DockerFile frontend"
          } else {
            error "Frontend Dockerfile not found (frontend/Dockerfile or frontend/DockerFile)."
          }

          sh "docker push ${backendTag}"
          sh "docker push ${frontendTag}"

          // also update :latest so compose referencing :latest works
          sh "docker tag ${backendTag} ${env.BACKEND_REPO}:latest || true"
          sh "docker tag ${frontendTag} ${env.FRONTEND_REPO}:latest || true"
          sh "docker push ${env.BACKEND_REPO}:latest || true"
          sh "docker push ${env.FRONTEND_REPO}:latest || true"

          echo "‚úÖ Images pushed: ${backendTag}, ${frontendTag}, and :latest."
        }
      }
    }

    stage('Deploy to EC2 (change host backend port)') {
      steps {
        script {
          def tag = env.BUILD_NUMBER ?: 'latest'
          def backendImageWithTag = "${env.BACKEND_REPO}:${tag}"
          def frontendImageWithTag = "${env.FRONTEND_REPO}:${tag}"

          withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'EC2_KEY_FILE', usernameVariable: 'EC2_USER_FROM_CRED')]) {
            // generate a deploy script we will copy to EC2 and run as sudo
            def deployScript = """#!/bin/bash
set -euo pipefail

APP_DIR="/home/${EC2_USER_FROM_CRED}/app"
COMPOSE_FILE="\$APP_DIR/docker-compose.yml"

echo "Ensuring app dir exists: \$APP_DIR"
mkdir -p "\$APP_DIR"
chown ${EC2_USER_FROM_CRED}:${EC2_USER_FROM_CRED} "\$APP_DIR" || true

echo "Pulling images: ${backendImageWithTag} , ${frontendImageWithTag}"
docker pull ${backendImageWithTag} || true
docker pull ${frontendImageWithTag} || true

if [ ! -f "\$COMPOSE_FILE" ]; then
  echo "ERROR: \$COMPOSE_FILE not found. Exiting."
  exit 2
fi

# Replace backend host port mapping in docker-compose.yml
# We expect a line like: - "8080:8080" (or with single quotes). Replace the left-side host port.
BACKEND_HOST_PORT=${BACKEND_HOST_PORT}
echo "Updating backend host port mapping in \$COMPOSE_FILE -> host:\$BACKEND_HOST_PORT:container:8080"
# Use sed to replace the first occurrence of host-port mapping for backend.
# This sed handles double quotes, single quotes and no quotes around the mapping.
# It replaces the left side of a mapping that ends with :8080
# Backup first
cp "\$COMPOSE_FILE" "\$COMPOSE_FILE.bak.$(date +%s)" || true

# Try to replace occurrences like "8080:8080", '8080:8080', 8080:8080
# If there is more than one mapping to :8080, this will replace them all ‚Äî adjust if that's undesirable.
sed -i -E \"s#(['\\\"]?)[0-9]{1,5}:8080\\1#\\1${BACKEND_HOST_PORT}:8080\\1#g\" "\$COMPOSE_FILE" || true

echo "Updated docker-compose.yml (showing diff):"
diff --unified=0 "\$COMPOSE_FILE.bak."* "\$COMPOSE_FILE" || true
echo "Restarting docker compose..."

if command -v docker-compose >/dev/null 2>&1; then
  docker-compose -f "\$COMPOSE_FILE" down || true
  docker-compose -f "\$COMPOSE_FILE" up -d
else
  docker compose -f "\$COMPOSE_FILE" down || true
  docker compose -f "\$COMPOSE_FILE" up -d
fi

echo "Deploy finished."
"""

            writeFile file: 'jenkins_deploy.sh', text: deployScript
            sh 'chmod +x jenkins_deploy.sh'

            // copy and run on remote EC2
            sh """
              scp -o StrictHostKeyChecking=no -i "$EC2_KEY_FILE" jenkins_deploy.sh ${EC2_USER_FROM_CRED}@${EC2_HOST}:/tmp/jenkins_deploy.sh
              ssh -o StrictHostKeyChecking=no -i "$EC2_KEY_FILE" ${EC2_USER_FROM_CRED}@${EC2_HOST} 'sudo chmod +x /tmp/jenkins_deploy.sh && sudo /bin/bash /tmp/jenkins_deploy.sh'
            """

            // cleanup local
            sh 'rm -f jenkins_deploy.sh || true'
          }
        }
      }
    }
  } // stages

  post {
    success {
      echo '‚úÖ Pipeline finished successfully.'
      script { sh 'docker logout || true' }
    }
    failure {
      echo '‚ùå Pipeline failed ‚Äî inspect logs.'
      script { sh 'docker logout || true' }
    }
  }
}
